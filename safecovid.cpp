#include "safecovid.h"

#include <algorithm>
#include <iostream>
#include <fstream>
#include <queue>
#include <limits>

using std::ifstream;
using std::string;
using std::vector;

/**
* Constructor that takes in a file to initialize graph
* This will use a default Person instead of user-provided information
* @param filename the name of the input file to establish vertices/edges
*/
safeCovid::safeCovid(const std::string &filename) : airportGraph(true, true), dijkstraGraph(true, true)
{
  // initialize weighted and directed graph
    initializeVertices(filename);
    initializeEdges(filename);
    initializeLabels();
}

/**
* Constructor that takes in a file to initialize graph
* This will use custom Person generated by having a provided age
* @param filename - Name of the input file to establish vertices/edges
*/
safeCovid::safeCovid(const std::string& filename, person pers) : airportGraph(true, true), person_(pers),
                                                                  dijkstraGraph(true, true)
{
    initializeVertices(filename);
    initializeEdges(filename);
    initializeLabels();
}

/**
* Generates all vertices based on airport data
* @param filename - Name of the input file to establish vertices/edges
*/
void safeCovid::initializeVertices(const std::string& filename) {
    ifstream edgesFile(filename);
    string line;
    //insert vertices
    if (edgesFile.is_open())
    {
        int count = 0;
        while (getline(edgesFile, line))
        {
            count++;
            vector<string> words;

            string delim = ",";
            size_t pos = 0;
            string word;
            while (true) // get the words from line and push to vector
            {
                pos = line.find(delim);
                if (pos == std::string::npos)
                {
                    words.push_back(line);
                    break;
                }
                word = line.substr(0, pos);
                line = line.substr(pos + 1);
                words.push_back(word);
            }
            // Add vertices to the graph
            airportGraph.insertVertex(words[2]);
            airportGraph.insertVertex(words[4]);
        }
    }
}

/**
* Generates all edges based on airport data
* @param filename - Name of the input file to establish vertices/edges
*/
void safeCovid::initializeEdges(const std::string& filename) {
    // insert edges
    ifstream edgesFile1(filename);
    string line1;

    if (edgesFile1.is_open())
    {
        int count = 0;
        while (getline(edgesFile1, line1))
        {
            count++;
            vector<string> words;

            string delim = ",";
            size_t pos = 0;
            string word;
            while (true) // get the words from line and push to vector
            {
                pos = line1.find(delim);
                if (pos == std::string::npos)
                {
                    words.push_back(line1);
                    break;
                }
                word = line1.substr(0, pos);
                line1 = line1.substr(pos + 1);
                words.push_back(word);
            }
            // Add vertices to the graph
            airportGraph.insertEdge(words[2], words[4]);
        }
    }
}

/**
* Create labels for the edge that includes its start and end airport.
*/
void safeCovid::initializeLabels() {
    vector<Edge> edges = airportGraph.getEdges();

    for (unsigned i = 0; i < edges.size(); i++) {
        string new_label = edges[i].source + "_" + edges[i].dest;
        airportGraph.setEdgeLabel(edges[i].source, edges[i].dest, new_label);
    }
}

/**
* Based on how COVID rates change between each airport,
* the edge weight reflects the magnitude of this change.
* A high positive weight indicates a strong increase in COVID rates,
* a low negative weight indicates a small decrease in COVID rates
*/
void safeCovid::initializeWeights() {
  vector<Edge> edges = airportGraph.getEdges();
  double rate1;
  double rate2;
  for (unsigned i = 0; i < edges.size(); i++) {
    if (airportGraph.getAdjacent(edges[i].source).size() != 0) {
      person_.rate(airportGraph.getAdjacent(edges[i].source).size());
      rate1 = person_.getRate();
    } else continue;
    if (airportGraph.getAdjacent(edges[i].dest).size() != 0) {
      person_.rate(airportGraph.getAdjacent(edges[i].dest).size());
      rate2 = person_.getRate();
    } else continue;
    airportGraph.setEdgeWeight(edges[i].source, edges[i].dest, rate2-rate1);
  }
}

/**
* Returns the graph of airports and flight paths
* @return - airports and flight paths graph
*/
Graph safeCovid::getAirportGraph() {
    return airportGraph;
}

/**
* Return the person object associated with each run
* @return - person object for this specific run
*/
person safeCovid::getPerson() {
    return person_;
}

/**
* Set the person object associated with each run
* @param age - age of the person
*/
void safeCovid::setPerson(float age) {
  person_.setAge(age);
  initializeWeights();
}

/**
* Initializes a BFS traversal beginning at the starting location.
* Without using weights, this will determine the quickest paths
* to each airport from the starting location.
* @param v - Vertex that indicated the airport where traversal begins.
*/
void safeCovid::BFSstart(Vertex v) {
    vector<Vertex> all_vertices = airportGraph.getVertices();
    vector<Edge> all_edges = airportGraph.getEdges();
    for (unsigned i = 0; i < all_vertices.size(); i++) {
        std::string temp = all_vertices[i];
        explore_vertices.insert({temp, "UNEXPLORED"});
    }
    for (unsigned i = 0; i < all_edges.size(); i++) {
        std::string temp = all_edges[i].getLabel();
        explore_edges.insert({temp, "UNEXPLORED"});
    }
    BFS(v);
    for (unsigned i = 0; i < all_vertices.size(); i++) {
        if (explore_vertices[all_vertices[i]] == "UNEXPLORED") {
            BFS(all_vertices[i]);
        }
    }
}

/**
* Helper function for the BFS traversal.
* This will check edges to determine where the traversal
* has already gone, as well as update labels to ensure
* which are discovery and cross edges in the graph.
* @param v - Vertex that indicated the airport where traversal begins.
*/
void safeCovid::BFS(Vertex v) {
    std::queue<Vertex> q;
    explore_vertices[v] = "EXPLORED";
    q.push(v);

    while (!q.empty()) {
        Vertex v = q.front();
        q.pop();
        for (Vertex w : airportGraph.getAdjacent(v)) {
            std::string label_e = v + "_" + w;
            if (explore_vertices[w] == "UNEXPLORED") {
                std::string name_edge_ = v + "_" + w;
                explore_edges[name_edge_] = "DISCOVERY";
                explore_vertices[w] = "VISITED";
                q.push(w);
                pred_vertex.insert({w, v});
            } else if (explore_edges[label_e] == "UNEXPLORED") {
                explore_edges[label_e] = "CROSS";
            }
        }
    }
}

/**
* Uses a BFS to determine the quickest path from a starting location
* to an end location. This does not take COVID rates into account
* and provides purely the shortest path.
* @param s - The starting airport
* @param d - The destination airport
* @return - vector where each entry is the IATA code for each airport along the path.
*/
vector<std::string> safeCovid::getPathBFS(Vertex s, Vertex d) {
    BFSstart(s);
    Vertex destination_ = d;
    Vertex start_ = s;
    vector<std::string> res_;
    res_.push_back(destination_);
    int count_checks = 0;
    while (count_checks < 10) {
        std::string pred_ = pred_vertex[destination_];
        res_.push_back(pred_);
        destination_ = pred_;
        if (pred_ == start_) {
            explore_edges.clear(); // clean variables so BFS can be used again
            explore_vertices.clear();
            pred_vertex.clear();
            return res_;
        }
    }
    explore_edges.clear(); // clean variables so BFS can be used again
    explore_vertices.clear();
    pred_vertex.clear();

    std::cout << "The length of the path exceeded 10 or there is no path from " << s << " to " << d << "."<<std::endl;
    vector<std::string> empty;
    return empty;
}

/**
* Prints the result from the shortest path determined by a BFS traversal.
* @param s - Starting airport
* @param d - Destination airport
*/
void safeCovid::printPathBFS(Vertex s, Vertex d) {
    if (s == d)
      std::cout << "Please choose a start and end that are not the same." << std::endl;
    if (!airportGraph.vertexExists(s)) {
      std::cout << "Sorry! You provided a starting airport that we do not have. Please run this again and make sure everything is spelled correctly or you are choosing a valid airport." << std::endl;
      return;
    } else if (!airportGraph.vertexExists(d)) {
      std::cout << "Sorry! You provided a destination airport that we do not have. Please run this again and make sure everything is spelled correctly or you are choosing a valid airport." << std::endl;
      return;
    }

    startVertex = s;
    vector<std::string> path_bfs = getPathBFS(s, d);
    if (path_bfs.size() == 0) return;
    std::cout << "Starting location: " << s << "    End location: " << d << std::endl;

    std::cout << "Path:  ";
    for (unsigned i = path_bfs.size()-1; i > 0; i--) {
        std::cout << path_bfs[i] << " -> ";
    }
    std::cout << path_bfs[0] << std::endl;
}

/**
* Uses a BFS to determine the quickest path from a starting location
* to an end location with a landmark that must be included.
* This does not take COVID rates into account and provides purely the shortest path.
* @param s - Starting airport
* @param d - Destination airport
* @return - vector where each entry is the IATA code for each airport along the path.
*/
vector<std::string> safeCovid::getPathLandmarkBFS(Vertex start, Vertex landmark, Vertex destination) {
    BFSstart(landmark);
    vector<std::string> to_start_path = getPathBFS(landmark, start);
    vector<std::string> to_dest_path = getPathBFS(landmark, destination);

    for (unsigned i = 1; i < to_dest_path.size(); i++) {
        to_start_path.push_back(to_dest_path[to_dest_path.size() - i - 1]);
    }
    return to_start_path;
}

/**
* Prints the result from the shortest path with a landmark determined by a BFS traversal.
* @param s - Starting airport
* @param d - Destination airport
*/
void safeCovid::printLandmarkPathBFS(Vertex start, Vertex landmark, Vertex destination) {
    if (start == destination)
      std::cout << "Please choose a start and end that are not the same." << std::endl;
    if (!airportGraph.vertexExists(start)) {
    std::cout << "Sorry! You provided a starting airport that we do not have. Please run this again and make sure everything is spelled correctly or you are choosing a valid airport." << std::endl;
    return;
  } else if (!airportGraph.vertexExists(destination)) {
    std::cout << "Sorry! You provided a destination airport that we do not have. Please run this again and make sure everything is spelled correctly or you are choosing a valid airport." << std::endl;
    return;
  } else if (!airportGraph.vertexExists(landmark)) {
    std::cout << "Sorry! You provided a landmark airport that we do not have. Please run this again and make sure everything is spelled correctly or you are choosing a valid airport." << std::endl;
    return;
  }

    startVertex = start;
    vector<std::string> landmark_path = getPathLandmarkBFS(start, landmark, destination);

    std::cout << "Starting location: " << start << "  Landmark:  " << landmark <<"    End location: " << destination << std::endl;

    std::cout << "Path:  ";
    for (unsigned i = 0; i < landmark_path.size()-1; i++) {
        std::cout << landmark_path[i] << " -> ";
    }
    std::cout << landmark_path[landmark_path.size()-1] << std::endl;
}


/**
* Generates a Single Source Shortest Path (SSSP) from a given vertex using Dijkstra's algorithm.
* This will take the edge weights into account when traversing.
* @param start - The vertex/airport to start from
*/
void safeCovid::DijkstraSSSP(Vertex start) {
  p.clear();
  d.clear();
  dijkstraGraph.clear();

  vector<Vertex> vertices = airportGraph.getVertices();

  for(Vertex v : vertices) {
    std::pair<Vertex, double> pair1 (v, std::numeric_limits<double>::infinity());
    d.insert(pair1);
    std::pair<Vertex, Vertex> pair2 (v, " ");
    p.insert(pair2);
  }
  d[start] = 0.0;

  heap<Vertex> pqueue (vertices);
  pqueue.addWeights(d);

  bool started = false;
  while (!pqueue.empty()) {
    Vertex u;
    if (!started) {
      u = start;
      started = true;
    } else u = pqueue.pop();
    dijkstraGraph.insertVertex(u);

    vector<Vertex> dijkstraVertices = dijkstraGraph.getVertices();
    for (Vertex v : airportGraph.getAdjacent(u)) {
      bool found = false;
      //Check if u's neighbor is already in the final graph
      for (Vertex vert : dijkstraVertices) {
        if (vert == v) {
          found = true;
          break;
        }
      }
      //If it's there, we skip over it and continue to another adjacent vertex
      if (found) continue;

      //Check to see if we found a cheaper path, since that's good
      if (airportGraph.getEdgeWeight(u, v) + d[u] < d[v]) {
        d[v] = airportGraph.getEdgeWeight(u, v) + d[u];
        pqueue.changeWeight(v, d[v]);
        //If v isn't in our queue, push it back in
        vector<Vertex> heapVertices;
        pqueue.getElems(heapVertices);
        bool exist = false;
        for (Vertex cur : heapVertices) {
          if (v == cur) {
            exist = true;
            break;
          }
        }
        if (!exist) {
          pqueue.push(v);
        }
        //Update it's new predecessor assuming a path to here from starter
        p[v] = u;
      }
    }
  }
}

/**
* Uses Dijkstra's algorithm to determine the safest path from a starting location
* to an end location. This takes COVID rates into account and
* provides the optimal path.
* @param s - The starting airport
* @param d - The destination airport
* @return - vector where each entry is the IATA code for each airport along the path.
*/
vector<std::string> safeCovid::getPathDijkstra(Vertex s, Vertex d) {
  startVertex = s;
  DijkstraSSSP(s);
  vector<Vertex> path;
  path.push_back(d);

  Vertex cur = d;
  if (p[d] == " ") {
    path.push_back(s);
  } else {
    while (p[cur] != " ") {
      path.push_back(p[cur]);
      cur = p[cur];
    }
  }

  p.clear();
  d.clear();
  dijkstraGraph.clear();
  return path;

}

/**
* Prints the result from the safest path determined by Dijkstra's algorithm.
* @param start - Starting airport
* @param dest - Destination airport
*/
void safeCovid::printPathDijkstra(Vertex start, Vertex dest) {
  if (start == dest)
    std::cout << "Please choose a start and end that are not the same." << std::endl;
  if (!airportGraph.vertexExists(start)) {
    std::cout << "Sorry! You provided a starting airport that we do not have. Please run this again and make sure everything is spelled correctly or you are choosing a valid airport." << std::endl;
    return;
  } else if (!airportGraph.vertexExists(dest)) {
    std::cout << "Sorry! You provided a destination airport that we do not have. Please run this again and make sure everything is spelled correctly or you are choosing a valid airport." << std::endl;
    return;
  }

  startVertex = start;
  vector<std::string> path_dijkstra = getPathDijkstra(start, dest);
  std::cout << "Starting location: " << start << "    End location: " << dest << std::endl;

  std::cout << "Path:  ";
  for (unsigned i = path_dijkstra.size()-1; i > 0; i--) {
      std::cout << path_dijkstra[i] << " -> ";
  }
  std::cout << path_dijkstra[0] << std::endl;
  std::cout << "Please exercise caution if you use any other path as you may have a higher risk of contracting COVID." << std::endl;
  std::cout << std::endl;
  std::cout << std::endl;
}

/**
* Uses Dijkstra's algorithm to determine the safest path from a starting location
* to an end location. This takes COVID rates into account and
* provides the optimal path.
* @param start - The starting airport
* @param landmark - Landmark airport to visit along the way
* @param dest - The destination airport
* @return - vector where each entry is the IATA code for each airport along the path.
*/
vector<std::string> safeCovid::getPathLandmarkDijkstra(Vertex start, Vertex landmark, Vertex destination) {
  vector<std::string> to_landmark_path = getPathDijkstra(start, landmark);
  vector<std::string> to_dest_path = getPathDijkstra(landmark, destination);

  for (unsigned i = 1; i <= to_landmark_path.size() / 2; i++) {
    std::string tmp = to_landmark_path[i-1];
    to_landmark_path[i-1] = to_landmark_path[to_landmark_path.size()-i];
    to_landmark_path[to_landmark_path.size()-i] = tmp;
  }

  for (unsigned i = 2; i < to_dest_path.size(); i++) {
    to_landmark_path.push_back(to_dest_path[to_dest_path.size()-i]);
  }
  to_landmark_path.push_back(destination);
  return to_landmark_path;
}

/**
* Prints the result from the safest path with a landmark
* determined by Dijkstra's algorithm.
* @param start - Starting airport
* @param landmark - Landmark airport to visit along the way
* @param destination - Destination airport
*/
void safeCovid::printLandmarkPathDijkstra(Vertex start, Vertex landmark, Vertex destination) {
  if (start == destination)
    std::cout << "Please choose a start and end that are not the same." << std::endl;
  if (!airportGraph.vertexExists(start)) {
    std::cout << "Sorry! You provided a starting airport that we do not have. Please run this again and make sure everything is spelled correctly or you are choosing a valid airport." << std::endl;
    return;
  } else if (!airportGraph.vertexExists(destination)) {
    std::cout << "Sorry! You provided a destination airport that we do not have. Please run this again and make sure everything is spelled correctly or you are choosing a valid airport." << std::endl;
    return;
  } else if (!airportGraph.vertexExists(landmark)) {
    std::cout << "Sorry! You provided a landmark airport that we do not have. Please run this again and make sure everything is spelled correctly or you are choosing a valid airport." << std::endl;
    return;
  }

  startVertex = start;
  vector<std::string> landmark_path = getPathLandmarkDijkstra(start, landmark, destination);

  std::cout << "Starting location: " << start << "  Landmark:  " << landmark <<"    End location: " << destination << std::endl;

  std::cout << "Path:  ";
  for (unsigned i = 0; i < landmark_path.size()-1; i++) {
    std::cout << landmark_path[i] << " -> ";
  }
  std::cout << destination << std::endl;
  std::cout << "Please exercise caution if you use any other path as you may have a higher risk of contracting COVID." << std::endl;
  std::cout << std::endl;
  std::cout << std::endl;

}
